# 标准库类型string
标准库类型***string*** 表示可变长的字符序列，使用 string 类型必须
```C++
#include<string>
using std::string
```

# 常用的string操作
## 定义和初始化string对象

类本身决定如何初始化类的对象。
一个类可以定义很多种初始化对象的方式：
+ 初始值的数量不同
+ 初始值的类型不同
```C++
string s1;                // 默认初始化，s1是一个空字符串
string s2 = s1;           // s2是s1的副本
string s3("hiya");        // s3是字面值“hiya" 的副本，除了字面值最后的那个空字符外
string s3 = "hiya";       // 等价于s3("hiya")。 s3是该字符串字面值的副本
string s4(10, 'c');       // S4的内容是cccccccccc
string s4(n, 'c');        // 把s4初始化为由连续n个字符组成的字符串

```

### 默认初始化
如果定义变量时没有指定初值，则变量被 **默认初始化（default initialized）**，此时变量被赋予了“默认值“ ，
如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。
定义在函数体内部的内置类型变量将不被初始化
一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它决定对象的初始值到底是什么。
绝大多数类都支持无须显式初始化而丁定义对象。
```cpp
	std::string empty;// empty 非显式地初始化为一个空字符串
	Sales_item item;// 被默认初始化的Sales_item 对象
```
>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。

### 直接初始化
如果使用 等号(=)初始化一个变量，实际上执行的是 **拷贝初始化（copy initialization）**, 编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是 **直接初始化(derect initialization)**
```cpp
string s5 = "hiya"; // 拷贝初始化
string s6("hiya");  // 直接初始化
string s7(10. 'c'); // 直接初始化， s7为cccccccccc

```

对于多个值一般只能使用直接初始化方式，若进行拷贝初始化的情况，需要显式地创建一个临时对象用于拷贝
```cpp
string s8 = string(10,'c'); // 拷贝初始化，s8为cccccccccc
// 实际是等价于
string temp(10, 'c'); // temp为ccccccccccc
string s8 = temp
```